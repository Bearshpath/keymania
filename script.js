document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elements ---
    const promptTextEl = document.getElementById('prompt-text');
    const keyboardEl = document.querySelector('.keyboard');
    const keyButtons = document.querySelectorAll('.key:not(.disabled-placeholder)');
    const repeatButton = document.getElementById('repeat-button');
    const audioToggleButton = document.getElementById('audio-toggle-button');
    const startButton = document.getElementById('start-button');
    const showAnswerButton = document.getElementById('show-answer-button');
    const lessonSelectEl = document.getElementById('lesson-select');
    const settingsButton = document.getElementById('settings-button');
    const settingsPanel = document.getElementById('settings-panel');
    const feedbackVolumeSlider = document.getElementById('feedback-volume-slider');
    const feedbackVolumeValue = document.getElementById('feedback-volume-value');
    const questionVolumeSlider = document.getElementById('question-volume-slider');
    const questionVolumeValue = document.getElementById('question-volume-value');
    const customLessonModal = document.getElementById('custom-lesson-modal');
    const closeModalButton = document.getElementById('modal-close');
    const cancelModalButton = document.getElementById('modal-cancel');
    const saveModalButton = document.getElementById('modal-save');
    const customCharOptionsDiv = document.getElementById('custom-char-options');

     // Element check
     if (!promptTextEl || !keyboardEl || !lessonSelectEl || !startButton || !customLessonModal || !customCharOptionsDiv || !settingsButton || !settingsPanel || !feedbackVolumeSlider || !questionVolumeSlider || !closeModalButton || !cancelModalButton || !saveModalButton) {
         console.error("CRITICAL ERROR: One or more essential HTML elements not found!"); alert("Initialization Error!"); return;
     }
     console.log("Essential DOM elements found.");


    // --- Configuration ---
    const SOUND_FOLDER = 'sounding/'; const SOUND_EXTENSION = '.ogg'; const FEEDBACK_DELAY_MS = 1000; const NEXT_SOUND_DELAY_MS = 400; const PHYSICAL_KEY_PRESS_DURATION = 150; const SHOW_ANSWER_DELAY_MS = 1500; const INCORRECT_STREAK_WEIGHT = 3; const BASE_WEIGHT = 1; const RECENCY_WEIGHT_FACTOR = 0.1; const MIN_CUSTOM_CHARS = 2;


    // --- Lesson Definition ---
    const allPossibleChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".split('');
    const lessons = [
        { name: "Lesson 1 (A-E)", chars: ['A', 'B', 'C', 'D', 'E'] },
        { name: "Lesson 2 (F-J)", chars: ['F', 'G', 'H', 'I', 'J'] },
        { name: "Lesson 3 (K-O)", chars: ['K', 'L', 'M', 'N', 'O'] },
        { name: "Lesson 4 (P-T)", chars: ['P', 'Q', 'R', 'S', 'T'] },
        { name: "Lesson 5 (U-Z)", chars: ['U', 'V', 'W', 'X', 'Y', 'Z'] },
        { name: "Lesson 6 (0-4)", chars: ['0', '1', '2', '3', '4'] },
        { name: "Lesson 7 (5-9)", chars: ['5', '6', '7', '8', '9'] },
        { name: "All Letters", chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('') },
        { name: "All Numbers", chars: "0123456789".split('') },
        { name: "All Chars", chars: allPossibleChars }
    ];
    const CUSTOM_LESSON_VALUE = "custom";


    // --- LocalStorage Keys ---
    const LS_KEYS = { lessonSelection: 'soundMania_lessonSelection', customChars: 'soundMania_customChars', feedbackVolume: 'soundMania_feedbackVolume', questionVolume: 'soundMania_questionVolume', isMuted: 'soundMania_isMuted' };

    // --- Web Audio API Setup ---
    let audioContext; function initAudioContext() { if (!audioContext && (window.AudioContext || window.webkitAudioContext)) { try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); console.log("AudioContext initialized."); } catch (e) { console.error("Web Audio API is not supported.", e); alert("Browser audio features not supported."); } } } function playTone(frequency = 440, duration = 0.1, type = 'sine', volume = 0.3) { if (!audioContext || isMuted) return; try { const o = audioContext.createOscillator(), g = audioContext.createGain(); o.type = type; o.frequency.setValueAtTime(frequency, audioContext.currentTime); g.gain.setValueAtTime(volume, audioContext.currentTime); g.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration); o.connect(g); g.connect(audioContext.destination); o.start(audioContext.currentTime); o.stop(audioContext.currentTime + duration); } catch (e) { console.error("Error playing tone:", e); } }


    // --- Game State ---
    let characterStats = {}; let currentCharacter = null; let currentAudio = null; let isMuted = false; let waitingForInput = false; let gameActive = false; let presentationCounter = 0; let currentLessonSelection = "1"; let customLessonChars = []; let previousLessonSelection = "1"; let feedbackVolume = 0.75; let questionVolume = 0.75;


    // --- Helper Functions ---
    function getCurrentLessonChars() { console.log(`getCurrentLessonChars called. currentLessonSelection: '${currentLessonSelection}'`); if (currentLessonSelection === CUSTOM_LESSON_VALUE) { console.log("Returning custom chars:", customLessonChars); return customLessonChars; } else { const lessonIndex = parseInt(currentLessonSelection, 10) - 1; console.log(`Calculated lessonIndex: ${lessonIndex}`); if (!lessons || lessons.length <= lessonIndex || lessonIndex < 0) { console.error(`Cannot get lesson data for index ${lessonIndex}.`); return []; } const lessonData = lessons[lessonIndex]; console.log("Accessed lessonData:", lessonData); const chars = lessonData?.chars || []; console.log("Returning predefined chars:", chars); return chars; } }


    // --- Functions ---

    function initializeCharacterStatsForLesson() { const lessonChars = getCurrentLessonChars(); characterStats = {}; presentationCounter = 0; lessonChars.forEach(char => { characterStats[char] = { presented: 0, correct: 0, incorrectStreak: 0, lastPresentedTurn: -1 }; }); console.log(`Character stats initialized for lesson: ${currentLessonSelection}`); }
    function updateUI() { console.log("updateUI: Starting..."); try { const lessonChars = getCurrentLessonChars(); console.log(`updateUI: Updating keyboard for ${lessonChars.length} chars in lesson '${currentLessonSelection}'`); keyButtons.forEach(button => { const key = button.dataset.key; if (lessonChars.includes(key)) { button.classList.add('learned'); button.disabled = false; } else { button.classList.remove('learned'); button.disabled = true; } }); console.log("updateUI: Keyboard updated."); if (isMuted) { audioToggleButton.classList.add('muted'); audioToggleButton.textContent = 'ðŸ”‡'; audioToggleButton.title = "Unmute Sound"; } else { audioToggleButton.classList.remove('muted'); audioToggleButton.textContent = 'ðŸ”Š'; audioToggleButton.title = "Mute Sound"; } console.log(`updateUI: Mute button updated (Muted: ${isMuted}).`); } catch (error) { console.error("ERROR during updateUI:", error); } console.log("updateUI: Finished."); }
    function showFeedback(isCorrect, isShownAnswer = false) { promptTextEl.classList.remove('correct', 'incorrect', 'shown-answer'); promptTextEl.style.display = 'block'; if (isShownAnswer) { promptTextEl.textContent = `Answer: ${currentCharacter}`; promptTextEl.classList.add('shown-answer'); playTone(440, 0.05, 'triangle', feedbackVolume * 0.5); } else if (isCorrect) { promptTextEl.textContent = 'Correct!'; promptTextEl.classList.add('correct'); playTone(700, 0.15, 'sine', feedbackVolume); } else { promptTextEl.textContent = 'Try again...'; promptTextEl.classList.add('incorrect'); playTone(200, 0.25, 'sawtooth', feedbackVolume); } if (!isShownAnswer) { setTimeout(() => { if (promptTextEl.textContent === 'Correct!' || promptTextEl.textContent === 'Try again...') { promptTextEl.textContent = '?'; promptTextEl.classList.remove('correct', 'incorrect'); } }, FEEDBACK_DELAY_MS); } }
    function getNextCharacterWeighted() { const lessonChars = getCurrentLessonChars(); if (!lessonChars || lessonChars.length === 0) return null; let weightedList = []; let totalWeight = 0; const now = presentationCounter; lessonChars.forEach(char => { const stats = characterStats[char]; if (!stats) { console.warn(`Missing stats for ${char} in lesson ${currentLessonSelection}, assigning base weight.`); weightedList.push({ char: char, weight: BASE_WEIGHT }); totalWeight += BASE_WEIGHT; return; } const errorFactor = stats.presented > 0 ? (stats.presented - stats.correct) : 0; const streakFactor = stats.incorrectStreak * INCORRECT_STREAK_WEIGHT; const turnsSinceLastSeen = stats.lastPresentedTurn === -1 ? now + 1 : now - stats.lastPresentedTurn; const recencyFactor = Math.max(0, Math.log(turnsSinceLastSeen + 1) * RECENCY_WEIGHT_FACTOR); const weight = Math.max(BASE_WEIGHT, BASE_WEIGHT + errorFactor + streakFactor + recencyFactor); totalWeight += weight; weightedList.push({ char: char, weight: weight }); }); if (totalWeight <= 0) { console.warn("Total weight zero, fallback random."); return lessonChars[Math.floor(Math.random() * lessonChars.length)]; } let randomNum = Math.random() * totalWeight; for (let i = 0; i < weightedList.length; i++) { if (randomNum < weightedList[i].weight) { return weightedList[i].char; } randomNum -= weightedList[i].weight; } console.warn("Weighted selection fallback."); return weightedList[weightedList.length - 1].char; }
    function playCharacterSound(char) { if (!char) { console.error("No character provided to playCharacterSound"); promptTextEl.textContent = "! Error !"; gameActive = false; startButton.textContent = `Start Lesson ${currentLessonSelection}`; startButton.style.display = 'block'; startButton.disabled = false; return; } if (currentAudio) { currentAudio.pause(); currentAudio.currentTime = 0; } char = char.toUpperCase(); const soundPath = `${SOUND_FOLDER}${char.toLowerCase()}${SOUND_EXTENSION}`; presentationCounter++; console.log(`Lesson ${currentLessonSelection} Turn ${presentationCounter}: Preparing ${soundPath}`); if (characterStats[char]) { characterStats[char].presented++; characterStats[char].lastPresentedTurn = presentationCounter; } else { console.warn(`Stats not found for character: ${char}`); } currentAudio = new Audio(soundPath); currentCharacter = char; waitingForInput = true; promptTextEl.textContent = '?'; promptTextEl.style.display = 'block'; promptTextEl.classList.remove('correct', 'incorrect', 'shown-answer'); console.log(`Attempting to play sound. Current Char: ${currentCharacter}, Waiting: ${waitingForInput}`); currentAudio.volume = questionVolume; console.log(`Set question volume to: ${questionVolume}`); if (!isMuted) { currentAudio.play().then(() => { console.log(`Sound playback started for ${currentCharacter}. Waiting: ${waitingForInput}`); }).catch(error => { console.error(`CORE ERROR playing sound for ${char}:`, error); if (error.name === 'NotAllowedError') { promptTextEl.textContent = `Browser blocked audio. Click first!`; waitingForInput = false; } else { promptTextEl.textContent = `! Sound Error for ${char} !`; } promptTextEl.classList.add('incorrect'); console.log(`Error caught. Waiting flag state: ${waitingForInput}`); }); } else { console.log(`(Muted) - Would play sound for ${char}. Waiting: ${waitingForInput}`); waitingForInput = true; } console.log(`playCharacterSound setup complete. Waiting: ${waitingForInput}`); }
    function playNextSound() { if(waitingForInput) { console.log("playNextSound called while already waiting for input. Skipping."); return; } if (!gameActive) { console.log("playNextSound called but game is not active."); return; } console.log("Getting next character..."); const charToPlay = getNextCharacterWeighted(); if (charToPlay) { playCharacterSound(charToPlay); } else { console.error("Could not get next character to play!"); promptTextEl.textContent = "! No Chars !"; gameActive = false; } }
    function processInput(selectedKey) { console.log(`PROCESS INPUT START >> Selected: ${selectedKey}, Current: ${currentCharacter}, Waiting: ${waitingForInput}, Active: ${gameActive}`); if (!waitingForInput || !gameActive) { console.warn(`Input ignored - Waiting: ${waitingForInput}, Active: ${gameActive}`); return; } waitingForInput = false; console.log(`Input lock acquired (waitingForInput set to false).`); if (!currentCharacter || !characterStats[currentCharacter]) { console.error(`Cannot process input: Invalid currentCharacter ('${currentCharacter}') or missing stats.`); setTimeout(() => { if(gameActive) waitingForInput = true; console.log("Re-enabled waiting after stat error timeout."); }, 1000); return; } const stats = characterStats[currentCharacter]; if (selectedKey === currentCharacter) { console.log("Processing CORRECT answer..."); showFeedback(true); stats.correct++; stats.incorrectStreak = 0; setTimeout(playNextSound, NEXT_SOUND_DELAY_MS); } else { console.log("Processing INCORRECT answer..."); showFeedback(false); stats.incorrectStreak++; setTimeout(() => { if (gameActive && (promptTextEl.textContent === '?')) { console.log("Re-enabling waitingForInput after incorrect feedback timeout."); waitingForInput = true; } else { console.log("Not re-enabling waitingForInput. Game Active:", gameActive, "Prompt:", promptTextEl.textContent); } }, FEEDBACK_DELAY_MS); } console.log(`Stats for ${currentCharacter}:`, JSON.parse(JSON.stringify(stats))); console.log("PROCESS INPUT END <<"); }
    function handleVirtualKeyPress(event) { const target = event.target; if (!target.classList.contains('key')) return; const isDisabled = target.disabled; const selectedKey = target.dataset.key; console.log(`VKeyPress: ${selectedKey}. Is Button Disabled? ${isDisabled}. Waiting: ${waitingForInput}. Active: ${gameActive}`); if (isDisabled) { console.warn(`VKeyPress Ignored: Button ${selectedKey} is disabled.`); return; } if (!gameActive || !waitingForInput) { console.warn(`VKeyPress Ignored: Not ready (Active: ${gameActive}, Waiting: ${waitingForInput})`); return; } console.log(`VKeyPress: ${selectedKey}. Calling processInput...`); initAudioContext(); processInput(selectedKey); }
    function handlePhysicalKeyPress(event) { if ((event.key === ' ' || event.code === 'Space') && !gameActive && startButton.style.display === 'block' && !startButton.disabled) { console.log("Spacebar pressed - Starting game sequence..."); event.preventDefault(); startGameSequence(); return; } console.log(`PKeyPress Down: ${event.key}. Active: ${gameActive}`); if (!gameActive ) { return; } let keyPressed = event.key.toUpperCase(); const currentChars = getCurrentLessonChars(); if (currentChars.includes(keyPressed)) { const buttonElement = document.querySelector(`.key[data-key="${keyPressed}"]`); if (buttonElement) { const isDisabled = buttonElement.disabled; console.log(`PKeyPress Check: Found button for ${keyPressed}. Is Disabled? ${isDisabled}. Waiting: ${waitingForInput}.`); if (!isDisabled && waitingForInput) { console.log(`PKeyPress Valid: ${keyPressed}. Calling processInput...`); buttonElement.classList.add('pressed'); setTimeout(() => { buttonElement.classList.remove('pressed'); }, PHYSICAL_KEY_PRESS_DURATION); initAudioContext(); processInput(keyPressed); } else { console.warn(`PKeyPress Ignored for ${keyPressed}: Button Disabled=${isDisabled}, Waiting=${waitingForInput}`); } } else { console.error(`PKeyPress Error: Could not find button element for ${keyPressed}!`); } } else { if (event.key !== ' ' && event.code !== 'Space') { console.log(`PKeyPress Ignored: Key ${keyPressed} not in current lesson.`); } } }
    function handleShowAnswer() { if (!gameActive || !currentCharacter || !waitingForInput) { console.log("Cannot show answer now."); return; } console.log(`Showing answer: ${currentCharacter}`); initAudioContext(); const stats = characterStats[currentCharacter]; if (stats) { stats.incorrectStreak++; console.log(`Stats for ${currentCharacter} (after show):`, JSON.parse(JSON.stringify(stats))); } else { console.warn(`Stats missing for ${currentCharacter} when showing answer.`); } waitingForInput = false; showFeedback(false, true); setTimeout(playNextSound, SHOW_ANSWER_DELAY_MS); }
    function repeatSound() { if (!gameActive) return; initAudioContext(); if (currentCharacter && currentAudio) { console.log("Repeating sound for:", currentCharacter); if (!isMuted) { currentAudio.volume = questionVolume; currentAudio.currentTime = 0; currentAudio.play().catch(e => console.error("Error repeating sound:", e)); } else { console.log("(Muted) - Would repeat sound"); } waitingForInput = true; } }
    function toggleMute() { isMuted = !isMuted; console.log("Muted state toggled:", isMuted); if (isMuted && currentAudio && !currentAudio.paused) { currentAudio.pause(); } updateUI(); try { localStorage.setItem(LS_KEYS.isMuted, isMuted.toString()); console.log("Saved isMuted state to localStorage:", isMuted); } catch (e) { console.error("Failed to save mute state to localStorage:", e); } }
    function resetForLesson() { console.log(`>>> resetForLesson START for selection: ${currentLessonSelection}`); gameActive = false; if (currentAudio) { try { currentAudio.pause(); } catch(e) { console.warn("Minor error pausing audio", e); } } currentCharacter = null; waitingForInput = false; try { initializeCharacterStatsForLesson(); console.log("resetForLesson: Stats initialized."); updateUI(); console.log("resetForLesson: UI updated."); promptTextEl.textContent = '?'; promptTextEl.style.display = 'none'; promptTextEl.classList.remove('correct', 'incorrect', 'shown-answer'); let buttonText = "Start Lesson"; let startDisabled = false; if (currentLessonSelection === CUSTOM_LESSON_VALUE) { if(customLessonChars.length >= MIN_CUSTOM_CHARS) { buttonText = "Start Custom Lesson"; } else { buttonText = `Select ${MIN_CUSTOM_CHARS}+ Custom Chars`; startDisabled = true; } } else { buttonText = `Start Lesson ${currentLessonSelection}`; } startButton.textContent = buttonText; startButton.style.display = 'block'; startButton.disabled = startDisabled; console.log(`resetForLesson: Start button set (Text: '${buttonText}', Disabled: ${startDisabled})`); } catch (error) { console.error("ERROR during resetForLesson:", error); } console.log(">>> resetForLesson END"); }

    // --- Refactored Start Game Logic ---
    function startGameSequence() { if (currentLessonSelection === CUSTOM_LESSON_VALUE && customLessonChars.length < MIN_CUSTOM_CHARS) { console.warn("Attempted to start invalid custom lesson."); alert(`Please select at least ${MIN_CUSTOM_CHARS} characters first.`); openCustomModal(); return; } initAudioContext(); console.log(`Starting practice for: ${currentLessonSelection === CUSTOM_LESSON_VALUE ? 'Custom Lesson' : 'Lesson ' + currentLessonSelection}`); gameActive = true; startButton.style.display = 'none'; startButton.disabled = true; promptTextEl.textContent = '?'; promptTextEl.style.display = 'block'; playNextSound(); }

    // --- Modal Functions ---
    function openCustomModal() { console.log("Opening custom modal. Current custom set:", customLessonChars); const checkboxes = customCharOptionsDiv.querySelectorAll('input[type="checkbox"]'); checkboxes.forEach(checkbox => { checkbox.checked = customLessonChars.includes(checkbox.value); }); customLessonModal.style.display = "block"; }
    function closeCustomModal() { console.log("Closing custom modal."); customLessonModal.style.display = "none"; if(lessonSelectEl.value === CUSTOM_LESSON_VALUE && currentLessonSelection !== CUSTOM_LESSON_VALUE) { console.log("Reverting dropdown to previous selection:", previousLessonSelection); lessonSelectEl.value = previousLessonSelection; currentLessonSelection = previousLessonSelection; /* Update state too */ } resetForLesson(); } // Call reset AFTER potential dropdown revert
    function saveCustomLesson() { const selectedChars = []; const checkboxes = customCharOptionsDiv.querySelectorAll('input[type="checkbox"]:checked'); checkboxes.forEach(checkbox => { selectedChars.push(checkbox.value); }); if (selectedChars.length < MIN_CUSTOM_CHARS) { alert(`Please select at least ${MIN_CUSTOM_CHARS} characters.`); return; } customLessonChars = selectedChars.sort(); currentLessonSelection = CUSTOM_LESSON_VALUE; previousLessonSelection = CUSTOM_LESSON_VALUE; console.log("Custom lesson saved:", customLessonChars); try { localStorage.setItem(LS_KEYS.customChars, JSON.stringify(customLessonChars)); localStorage.setItem(LS_KEYS.lessonSelection, currentLessonSelection); console.log("Saved custom lesson and selection to localStorage."); } catch (e) { console.error("Failed to save custom lesson state to localStorage:", e); } customLessonModal.style.display = "none"; resetForLesson(); }

    // --- Load State Function ---
    function loadStateFromLocalStorage() { console.log("Attempting to load state from localStorage..."); try { const savedSelection = localStorage.getItem(LS_KEYS.lessonSelection); const savedCustomChars = localStorage.getItem(LS_KEYS.customChars); const savedFeedbackVol = localStorage.getItem(LS_KEYS.feedbackVolume); const savedQuestionVol = localStorage.getItem(LS_KEYS.questionVolume); const savedIsMuted = localStorage.getItem(LS_KEYS.isMuted); if (savedSelection !== null) { currentLessonSelection = savedSelection; previousLessonSelection = savedSelection; console.log("Loaded lessonSelection:", currentLessonSelection); } if (savedCustomChars !== null) { try { customLessonChars = JSON.parse(savedCustomChars); if (!Array.isArray(customLessonChars)) { console.warn("Loaded customChars was not an array, resetting."); customLessonChars = []; localStorage.removeItem(LS_KEYS.customChars); } else { console.log("Loaded customChars:", customLessonChars); } } catch (e) { console.error("Failed to parse saved customChars, resetting:", e); customLessonChars = []; localStorage.removeItem(LS_KEYS.customChars); } } if (currentLessonSelection === CUSTOM_LESSON_VALUE && customLessonChars.length < MIN_CUSTOM_CHARS) { console.warn("Loaded selection was custom, but custom chars invalid/insufficient. Reverting to lesson 1."); currentLessonSelection = "1"; previousLessonSelection = "1"; localStorage.setItem(LS_KEYS.lessonSelection, "1"); } if (savedFeedbackVol !== null) { const vol = parseFloat(savedFeedbackVol); if (!isNaN(vol) && vol >= 0 && vol <= 1) { feedbackVolume = vol; console.log("Loaded feedbackVolume:", feedbackVolume); } else { console.warn("Invalid feedbackVolume found in localStorage:", savedFeedbackVol); } } if (savedQuestionVol !== null) { const vol = parseFloat(savedQuestionVol); if (!isNaN(vol) && vol >= 0 && vol <= 1) { questionVolume = vol; console.log("Loaded questionVolume:", questionVolume); } else { console.warn("Invalid questionVolume found in localStorage:", savedQuestionVol); } } if (savedIsMuted !== null) { isMuted = (savedIsMuted === 'true'); console.log("Loaded isMuted:", isMuted); } } catch (e) { console.error("Error loading state from localStorage:", e); } console.log("Finished loading state."); }

    // --- Game Initialization ---
    function initializeGame() { console.log(">>> initializeGame START"); try { loadStateFromLocalStorage(); lessonSelectEl.innerHTML = ''; lessons.forEach((lesson, index) => { const option = document.createElement('option'); option.value = index + 1; option.textContent = lesson.name; lessonSelectEl.appendChild(option); }); const customOption = document.createElement('option'); customOption.value = CUSTOM_LESSON_VALUE; customOption.textContent = "Custom..."; lessonSelectEl.appendChild(customOption); console.log("initializeGame: Dropdown populated."); customCharOptionsDiv.innerHTML = ''; allPossibleChars.forEach(char => { const div = document.createElement('div'); div.className = 'char-option'; const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.id = `custom-char-${char}`; checkbox.value = char; const label = document.createElement('label'); label.htmlFor = `custom-char-${char}`; label.textContent = char; div.appendChild(checkbox); div.appendChild(label); customCharOptionsDiv.appendChild(div); }); console.log("initializeGame: Modal populated."); lessonSelectEl.value = currentLessonSelection; feedbackVolumeSlider.value = feedbackVolume * 100; feedbackVolumeValue.textContent = feedbackVolumeSlider.value; questionVolumeSlider.value = questionVolume * 100; questionVolumeValue.textContent = questionVolumeSlider.value; console.log("initializeGame: UI elements set from state."); resetForLesson(); } catch(error) { console.error("CRITICAL ERROR during initializeGame:", error); alert("Page initialization failed! Check console (F12)."); } console.log(">>> initializeGame END"); }


    // --- Event Listeners ---
    keyboardEl.addEventListener('click', handleVirtualKeyPress);
    document.addEventListener('keydown', handlePhysicalKeyPress);
    repeatButton.addEventListener('click', repeatSound);
    audioToggleButton.addEventListener('click', toggleMute); // Use the correct handler
    showAnswerButton.addEventListener('click', handleShowAnswer);
    settingsButton.addEventListener('click', () => { const isVisible = settingsPanel.style.display === 'block'; settingsPanel.style.display = isVisible ? 'none' : 'block'; console.log(`Settings panel ${isVisible ? 'hidden' : 'shown'}`); });
    feedbackVolumeSlider.addEventListener('input', (event) => { const value = event.target.value; feedbackVolume = value / 100; feedbackVolumeValue.textContent = value; console.log(`Feedback volume changed to: ${feedbackVolume}`); try { localStorage.setItem(LS_KEYS.feedbackVolume, feedbackVolume.toString()); } catch (e) { console.error("Failed to save feedback volume:", e); } });
    questionVolumeSlider.addEventListener('input', (event) => { const value = event.target.value; questionVolume = value / 100; questionVolumeValue.textContent = value; console.log(`Question volume changed to: ${questionVolume}`); if (currentAudio) { currentAudio.volume = questionVolume; } try { localStorage.setItem(LS_KEYS.questionVolume, questionVolume.toString()); } catch (e) { console.error("Failed to save question volume:", e); } });
    lessonSelectEl.addEventListener('change', (event) => { const selectedValue = event.target.value; if (selectedValue === CUSTOM_LESSON_VALUE) { openCustomModal(); } else { if (selectedValue !== currentLessonSelection) { previousLessonSelection = currentLessonSelection; currentLessonSelection = selectedValue; try { localStorage.setItem(LS_KEYS.lessonSelection, currentLessonSelection); console.log("Saved lessonSelection to localStorage:", currentLessonSelection); } catch (e) { console.error("Failed to save lesson selection to localStorage:", e); } resetForLesson(); } } });
    closeModalButton.addEventListener('click', closeCustomModal);
    cancelModalButton.addEventListener('click', closeCustomModal);
    saveModalButton.addEventListener('click', saveCustomLesson);
    window.addEventListener('click', (event) => { if (event.target == customLessonModal) { closeCustomModal(); } });
    startButton.addEventListener('click', startGameSequence); // Use refactored function

    // --- Initialisation ---
    initializeGame();

});